    
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="open-closed-principle">
<h1><span class="section-number">11.4. </span>Open/Closed Principle<a class="headerlink" href="#open-closed-principle" title="Permalink to this headline">¶</a></h1>
<p>The <strong>Open/Closed Principle</strong> (OCP) of SOLID states that classes should be “open for
extension, but closed against modification.” That is, it should be possible to
extend the behavior of classes without modifying existing code on which other
classes or apps depend.</p>
<p>While adding subclasses that inherit from a base class is one way to extend existing
classes, it’s often not enough by itself. Figure 11.10 shows why the presence of <code class="code docutils literal notranslate"><span class="pre">case</span></code>-based
dispatching logic—one variant of the <em>Case Statement</em> design smell—suggests a possible OCP violation.</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">Report</span>
<span class="linenos"> 2</span>    <span class="k">def</span> <span class="nf">output</span>
<span class="linenos"> 3</span>        <span class="n">formatter</span> <span class="o">=</span>
<span class="linenos"> 4</span>        <span class="k">case</span> <span class="vi">@format</span>
<span class="linenos"> 5</span>        <span class="k">when</span> <span class="ss">:html</span>
<span class="linenos"> 6</span>            <span class="no">HtmlFormatter</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
<span class="linenos"> 7</span>        <span class="k">when</span> <span class="ss">:pdf</span>
<span class="linenos"> 8</span>            <span class="no">PdfFormatter</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
<span class="linenos"> 9</span>            <span class="c1"># ... etc</span>
<span class="linenos">10</span>        <span class="k">end</span>
<span class="linenos">11</span>    <span class="k">end</span>
<span class="linenos">12</span><span class="k">end</span>
</pre></div>
</div>

<figure>
  <figcaption>
  Figure 11.10: The Report class depends on a base class Formatter with subclasses HtmlFormatter and PdfFormatter.
Because of the explicit dispatch on the report format, adding a new type of report output requires modifying
Report#output, and probably requires changing other methods of Report that have similar logic—so-called shotgun
surgery.
  </figcaption>
</figure> 

<p>Depending on the specific case, various design patterns can help. One problem that the smelly
code in Figure 11.10 is trying to solve is that the desired subclass of <code class="code docutils literal notranslate"><span class="pre">Formatter</span></code> isn’t known
until runtime, when it is stored in the <code class="code docutils literal notranslate"><span class="pre">&#64;format</span></code> instance variable. The <strong>abstract factory pattern</strong>
provides a common interface for instantiating an object whose subclass may not be known until
runtime. Ruby’s duck typing and metaprogramming enable a particularly elegant implementation
of this pattern, as Figure 11.11 shows. (In statically-typed languages, to “work around” the
type system, we have to create a factory method for each subclass and have them all implement
a common interface—hence the name of the pattern.)</p>
<div class="highlight-ruby notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nc">Report</span>
<span class="linenos"> 2</span>    <span class="k">def</span> <span class="nf">output</span>
<span class="linenos"> 3</span>        <span class="n">formatter_class</span> <span class="o">=</span>
<span class="linenos"> 4</span>        <span class="k">begin</span>
<span class="linenos"> 5</span>            <span class="vi">@format</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">classify</span><span class="o">.</span><span class="n">constantize</span>
<span class="linenos"> 6</span>        <span class="k">rescue</span> <span class="no">NameError</span>
<span class="linenos"> 7</span>            <span class="c1"># ...handle &#39;invalid formatter type&#39;</span>
<span class="linenos"> 8</span>        <span class="k">end</span>
<span class="linenos"> 9</span>        <span class="n">formatter</span> <span class="o">=</span> <span class="n">formatter_class</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:new</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
<span class="linenos">10</span>        <span class="c1"># etc</span>
<span class="linenos">11</span>    <span class="k">end</span>
<span class="linenos">12</span><span class="k">end</span>
</pre></div>
</div>

<figure>
  <figcaption>
  Figure 11.11: Ruby’s metaprogramming and duck typing enable an elegant implementation of the abstract factory
  pattern. classify is provided by Rails to convert snake_case to UpperCamelCase. constantize is syntactic sugar
  provided by Rails that calls the Ruby introspection method Object#const_get on the receiver. We also handle the case of
  an invalid value of the formatter class, which the bad code doesn’t.
  </figcaption>
</figure>

<p>Another approach is to take advantage of the <strong>Strategy pattern</strong> or <strong>Template Method pattern</strong>. Both
support the case in which there is a general approach to doing a task but many possible variants.
The difference between the two is the level at which commonality is captured. With Template
Method, although the implementation of each step may differ, the set of steps is the same for
all variants; hence it is usually implemented using inheritance. With Strategy, the overall
task is the same, but the set of steps may be different in each variant; hence it is usually
implemented using composition. Figure 11.12 shows how either pattern could be applied to the
report formatter. If every kind of formatter followed the same high- level steps—for example,
